<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>COMS W4995 : Graph Library: A C++ Graph Library Using Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">COMS W4995 : Graph Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">A C++ <a class="el" href="structGraph.html" title="Graph structure ">Graph</a> Library Using Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>What is this repo?</h2>
<p>It's a graph library, built in C++, that makes it easy to create and use graphs. Currently the library supports the following graphs: <a class="el" href="structDG.html" title="Directed Graph structure ">DG</a> (directed graph), <a class="el" href="structDAG.html" title="Directed Acyclic Graph structure ">DAG</a> (directed acyclic graph), <a class="el" href="structDT.html" title="Tree structure ">DT</a> (directed tree), Matrix(undirected). The idea is that users define their own vertex and edge data types, and then the library handles everything else under the hood.</p>
<p>Conceptually, a graph is made up of a bunch of vertices and edges. At a minimum there must be some way to distinguish between vertices, distinguish between edges, and define edges as made up of two vertices. Nontheless, users often want to embed extra information in these ADTs. For example, a user may want a graph representing cities and the highways between them. The user may have a City class; cities must of course have some unique id (e.g. city name), but they may also have extra information such as population, GDP, etc. The same goes for edges; maybe a Road class is used, and the class also has miles, age of road etc. This library makes it easy for users to provide their own ADTs, and immediately start creating graphs, and run algoritms on them.</p>
<h2>What are C++ concepts?</h2>
<p><a href="http://www.stroustrup.com/good_concepts.pdf">http://www.stroustrup.com/good_concepts.pdf</a></p>
<p>They're essentially compile time predicates. That is, they are requirements on the types that are passed into functions. If an argument doesn't satisfy the concept, the compiler will immediately report an error. This makes debugging much easier when using templates. Without concepts, debugging can be very tricky when using templates, as it's often late in the compilation process that the compiler realizes a type is no good. As a result error messages can be extremely long, making dubugging tricky. In terms of this library, the idea is that user defined vertices and edges must satisfy certain properties; concepts are used to enforce these.</p>
<h2><a class="el" href="structGraph.html" title="Graph structure ">Graph</a> Terminology</h2>
<p><a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">https://en.wikipedia.org/wiki/Graph_(abstract_data_type)</a></p>
<h2>Why use this repo?</h2>
<ul>
<li>I've tried to make it so that it is really easy for users to use their own vertex/edge data structures so they can start using graphs right away and run algorithms on them.</li>
<li>Concepts support overloading, so the right function is selected at compile depending on the actual argument types. Thus, there is no runtime overhead in terms of looking up which function to call.</li>
<li>Concepts make debugging easier. Bugs are caught earlier in the compilation process (when the concept predicate is checked). Often when programming with templates errors are caught late in the compilation process, resulting in hard to read error messages. Concepts will make sure the compiler knows right away an argument's type is no good</li>
</ul>
<h2>Using the library</h2>
<ul>
<li>The most important thing is for the user to define his/her vertex and edge data types. The only requirements are that the vertex/edge are comparable (aka must implement operator==) and hashable (aka implement struct hash&lt;vertex&gt; ...).</li>
<li>Then the user should select one of graph_dg, graph_dag, graph_dt, matrix_graph and provide the struct with two template parameters that specify the vertex and edge types (as mentioned above the lib provides vertex and edge for this but the user can use his/her own data types) e.g. dag_graph&lt;my_vertex_1, my_edge_1&gt; my_graph; e.g. dt_graph&lt;vertex, edge&gt; my_graph; e.g. dg_graph&lt;my_vertex_2, my_edge_2&gt; my_graph;</li>
<li>At this point any/all of the functions can be used. Note that all functions require pointers as inputs (more specifically shared_ptrs); this is to avoid the cost of copying large graphs/vertices/edges<ul>
<li>see examples/ directory for some examples</li>
</ul>
</li>
<li>Note that the same function name is used for all graph types, vertex types and edge types. This is another benefit of concepts; that is, concepts are used to make sure the right function is called using overloading</li>
</ul>
<h3>Other</h3>
<ul>
<li>The user can use the create_vertex code iff the data type provided by the user has unique id that is an int, and get be retrieved via get_key(). I use a concept to guarantee only graphs whose vertices are of the right type can call this code. This is a nice helper function that can be used to create lots of user defined vertices; again though the unique id for the user defined vertex must be an int retrievable from get_key()</li>
</ul>
<h3>Path algorithms</h3>
<ul>
<li>Bfs, dfs, ucs and ast implementations exist for all types of graph</li>
<li>The code that runs the algos is in <a class="el" href="node__expander__path__algorithms_8h.html" title="Node Expander Path Finding algorithms are implemented here. ">node_expander_path_algorithms.h</a></li>
<li>Whats nice is that there is one and only one path finding algorithm in <a class="el" href="node__expander__path__algorithms_8h.html" title="Node Expander Path Finding algorithms are implemented here. ">node_expander_path_algorithms.h</a>. The inputs are simply the goal state, the frontier type (e.g. stack, queue, heap), and the operations that work on the frontier. This way bfs, dfs, ucs and ast can all work with the same code</li>
<li>In fact, as the code in expander_examples/ directory show, you dont even need a graph to use the path finding algorithms. As long as you send the algorithm an initial state, goal state and frontier (plus it's operations), that adhere to a few properties (explained below) you are good to go<ul>
<li>the states must have an expand function that returns a vector of successor states</li>
<li>the state must have a cost field</li>
<li>take a look at <a href="https://en.wikipedia.org/wiki/Pathfinding">https://en.wikipedia.org/wiki/Pathfinding</a> for more reference</li>
</ul>
</li>
</ul>
<h2>Implementation</h2>
<ul>
<li>Created structs for <a class="el" href="structDAG.html" title="Directed Acyclic Graph structure ">DAG</a>, <a class="el" href="structDG.html" title="Directed Graph structure ">DG</a>, <a class="el" href="structDT.html" title="Tree structure ">DT</a>, Matrix<ul>
<li>dg_graph, dag_graph, dt_graph, matrix_graph</li>
<li>each have a member type called 'graph_type'</li>
<li>use concepts to differentiate between them based on this member type 'graph_type'</li>
<li>created dummy structs "Graph" "DAG" "DG" "DT" "Matrix_graph" so that the member type 'graph_type' can be set to one of these</li>
</ul>
</li>
<li>The AL structs use an vector to hold vertex and edge information<ul>
<li>Created structs for vertex and edge, but user can also provide his/her own implementation as long as their data type is comparable</li>
<li>lib provided structs are just called vertex and edge</li>
<li>users can provide custom built vertices/edges for their specific needs as mentioned previously</li>
</ul>
</li>
<li>For the matrix implementation, i map a vertex to a unique id. This unique id is used to index the matrix. Note, the unique is hidden from the user; thus, the user's vertex does not need to maintain it's own index. This was a design design I made to make it super easy for the user to get going right away. Nonetheless, there is some overhead in storing this mapping.</li>
<li>Use concept overloading to choose which function to call depending on the graph type</li>
<li>Reach out to me with any implementation questions</li>
</ul>
<h2>Location of Code</h2>
<ul>
<li>in src/ directory</li>
<li><a class="el" href="adjacency__list__graph__lib_8h.html" title="Adjacency list implementation for Graph. ">adjacency_list_graph_lib.h</a> contains all adjacency list code</li>
<li><a class="el" href="matrix__graph__lib_8h.html" title="Adjacency Matrix implementation for a Graph. ">matrix_graph_lib.h</a> contains all matrix code</li>
<li><a class="el" href="graph__structs_8h.html" title="Structs that are used to define a graph are defined here. ">graph_structs.h</a> contains the data structures the lib uses</li>
</ul>
<h2>Environment</h2>
<ul>
<li>Development:<ul>
<li>OS: Ubuntu 16.10</li>
<li>C++ standard libary used: c++1z</li>
<li>Compiler: g++</li>
<li>Compiler options: -fconcepts</li>
</ul>
</li>
<li>Third party code:<ul>
<li>used a bunch of code from <a href="https://github.com/CaseyCarter/cmcstl2">https://github.com/CaseyCarter/cmcstl2</a></li>
<li>all the concepts from this repo are in cmcstl2/</li>
</ul>
</li>
</ul>
<h2>Compiling</h2>
<ul>
<li>Take a look at Makefile in examples/<ul>
<li>to compile: make</li>
<li>to clean: make clean</li>
<li>to clean dir and recompile: make all</li>
<li>to debug/run with valgrind: make valgrind</li>
</ul>
</li>
</ul>
<h2>Important Notes</h2>
<ul>
<li>There appears to be a GCC bug when it comes to compiling concepts. There are times where private member variables/functions can suddenly be accessed from outside a class/struct (very weird). See <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78715">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78715</a> for this bug report</li>
</ul>
<h2>Examples</h2>
<ul>
<li>Take a look at main.cpp in examples/, cities_examples/ expander_examples/ directory for examples. The makefiles should be set up so you can simply run 'make', and execute the binary (./main) </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 27 2017 23:01:08 for COMS W4995 : Graph Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
